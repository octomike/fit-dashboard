---
title: "Runboard"
output: 
  flexdashboard::flex_dashboard:
    css: styles.css
    theme: united
    orientation: rows
    social: menu
runtime: shiny
---

```{r setup, include=FALSE}
library(flexdashboard)
library(dplyr)
library(leaflet)
library(tidyr)
library(dygraphs)
library(xts)
library(stringr)
library(elevatr)
library(rgdal)
library(ggplot2)
library(devtools)
library(lubridate)
library(fit) # install_github('octomike/fit')
library(zoo)

options(shiny.reactlog = FALSE)


# helpers
source("helpers/data.R")

# global variables
elevationCache <- reactiveVal(NULL)

hrLabels <- reactiveVal(c('Z1', 'Z2', 'Z3', 'Z4', 'Z5'))
hrMethod <- reactiveVal(NULL)
methodLabels <- c('Automatic', 'Lactate Threshold', 'Maximum HR')
hrColors <- c('#c4ced4', '#b0dcf7', '#b9dfa0', '#fbd89e', '#faa8b1')
hlCallbackJs <- 'function(event, x, points, row, seriesName){
  Shiny.setInputValue("currentLocation", row);
  for (div of document.getElementsByClassName("dygraphs")) {
    var obj = window.HTMLWidgets.getInstance(div);
    obj.dygraph.setSelection(row);
  }
}'
```


Sidebar {.sidebar}
==================

### Open activity:

```{r}
fileInput('fitFile', label='Only .fit files are supported')
```


### Heart Rate Zones

```{r}
selectInput('hrmethod', 'HR based on', choices=methodLabels)
sliderInput('hrthresh', 'HR in bpm', value=180, min=150, max=220)
```

### Elevation Correction

If your device does not have a barometric sensor, try to correct GPS data with a [external radar data](https://cran.r-project.org/web/packages/elevatr/vignettes/introduction_to_elevatr.html).

```{r}
checkboxInput('fixElevation', label='Fix Elevation', value=FALSE)
```


```{r}
# hide inputs with css and use from dygraph JS callbacks
numericInput('currentLocation', '', value=1)
dateInput('rangeStart', '', NULL)
dateInput('rangeStop', '', NULL)
```

```{r}

# rawdata contains $records timeseries and some metadata
rawdata <- reactive({
  req(input$fitFile)
  elevationCache(NULL) # drop the cache
  read.fit(input$fitFile$datapath)
})

# data cleaning and fixing
fitdata <- reactive({
    raw <- rawdata()
    if ( str_detect(input$hrmethod, 'Automatic') ) {
      if ( 'threshold_heart_rate' %in% names(raw$zones_target) ) {
        updateSliderInput(session, 'hrthresh',label='Lactate HR in bpm (from fit file)',
                          min=150, max=220, value=raw$zones_target$threshold_heart_rate)
        updateSelectInput(session, 'hrmethod', label='HR based on', selected=methodLabels[1])
        hrMethod('lactate')
      }
      else if ( 'max_heart_rate' %in% names(raw$zones_target) ) {
        updateSliderInput(session, 'hrthresh', label='Max HR in bpm (from fit file)',
                          min=150, max=220, value=raw$zones_target$max_heart_rate)
        updateSelectInput(session, 'hrmethod', label='HR based on', selected=methodLabels[1])
        hrMethod('max')
      }
    }
    else if ( str_detect(input$hrmethod, 'Lactate') ) {
      updateSliderInput(session, 'hrthresh', label='Lactate HR in bpm',
                        min=150, max=220, value=180)
      updateSelectInput(session, 'hrmethod', label='HR based on', selected=methodLabels[2])
      hrMethod('lactate')
    }
    else {
      updateSliderInput(session, 'hrthresh', label='Max HR in bpm',
                        min=150, max=220, value=180)
      updateSelectInput(session, 'hrmethod', label='HR based on', selected=methodLabels[3])
      hrMethod('max')
    }
    df <- raw$record %>%
      run_rename_select %>%
      run_fix_resolution %>%
      run_fix_units %>%
      run_fix_elevation(skip=!input$fixElevation, cache=elevationCache()) %>%
      run_add_pace

    # cache elevation fix
    if (input$fixElevation && is.null(elevationCache())) {
      elevationCache(df$altitude)
    }
    df
})

# limit data to range from dygraph
rangedata <- reactive({
  fitdata() %>%
    run_filter_fitrange(start=input$rangeStart, stop=input$rangeStop) %>%
    run_add_hrzone(breaks=hrBreaks(), labels=hrLabels())
})

# reduce resolution for a quicker map
mapdata <- reactive({
  rd <- rangedata()
  tres <- rd %>%
            mutate(td=as.numeric(timestamp - lag(timestamp), units='secs')) %>%
            select('td') %>%
            drop_na() %>% 
            summarise(mean(td)) %>%
            pull()

  if (tres <= 2){
    rd %>%
      filter(!(row_number() %% max(floor(tres), 4))) # TODO consider making this an input
  } else {
    rd
  }
})

# prepare data for HRDP estimation
analysisdata <- reactive({
  rangedata() %>%
    run_add_masks(slopeWindow=input$slopeWindow, hrWindow=input$hrWindow, speedWindow=input$speedWindow,
                  slopeLimit=input$slopeLimit, hrLimit=input$hrLimit, speedLimit=input$speedLimit) %>%
    select(c('slope', 'pace', 'hr', 'hrzone', 'speed', 'combinedmask')) %>%
    filter(pace < 8) %>%
    filter(hr >= input$HRrange[1]) %>%
    filter(hr <= input$HRrange[2]) %>%
    filter(combinedmask) %>%
    group_by(hr) %>%
    filter(n()>input$minGroup) %>%
    filter((abs(pace - median(pace)) <= 2 * sd(pace))) %>%
    mutate(med=median(speed), avg=mean(speed),
           lwr=median(speed)-sd(speed), upr=median(speed) + sd(speed)) %>%
    ungroup
})

# depends on maximum hr in range
# used to restrict the extent of HR-Zone-plot
hrBreaks <- reactive({
  req(input$hrthresh, input$fitFile)
  thresh <- input$hrthresh
  # https://www.researchgate.net/figure/The-5-Zone-Intensity-Scale-Used-by-the-Norwegian-Olympic-Federation-and-the-3-Zone-and_tbl1_259652575
  breaks <- thresh * c(0.72, 0.82, 0.87, 0.92, 1)
  if ( hrMethod() == 'lactate' ) {
    breaks <- breaks / 0.92
  }
  breaks <- round(breaks)
  c(min(breaks[1]-1, min(fitdata()$hr)), breaks)
})

```

Summary
=======

Row
---

### Pace {.value-box}

```{r}
avgPace <- reactive({
  data <- rangedata()
  d <- ( tail(data$distance, n=1) - head(data$distance, n=1) ) / 1000
  t <- as.numeric(
    difftime(tail(data$timestamp, n=1), data$timestamp[1], unit='mins')
  )
  pace <- t/d
  list(string=sprintf('%s min/km', format_pace(pace)), numeric=pace)
})

renderValueBox({
  value <- avgPace()
  valueBox(value = value$string, icon = "fa-tachometer-alt", color = 'success')
})
```

### Time {.value-box}

```{r}
runTime <- reactive({
  data <- rangedata() %>% slice(1, n()) %>%  select('timestamp') %>% pull
  diff <- as.numeric(data[2] - data[1], units='secs')
  list(string=tolower(seconds_to_period(diff)), numeric=diff)
})

renderValueBox({
  value <- runTime()
  valueBox(value = value$string, icon = "fa-stopwatch", color = 'success')
})
```

### Distance {.value-box}

```{r}
distance <- reactive({
  data <- rangedata()
  d <- ( tail(data$distance, n=1) - head(data$distance, n=1) ) / 1000
  list(string=sprintf('%0.2f km', d), numeric=d)
})

renderValueBox({
  value = distance()
  valueBox(value = value$string, icon = "fa-road", color = 'success' )
})
```


### Elevation Slope (imprecise) {.value-box}

```{r}
elSlope <- reactive({
  slopes <- rangedata()$slope
  slope <- floor(sum( slopes[slopes>0] ))
  list(string=sprintf('%d m', slope), numeric=slope)
})

renderValueBox({
  value <- elSlope()
  valueBox(value = value$string, icon = "fa-signal", color = 'success')
})
```

### Average HR {.value-box}

```{r}
avgHR <- reactive({
  avghr <- round(mean(rangedata()$hr))
  list(string=sprintf('%d bpm', avghr), numeric=avghr)
})

renderValueBox({
  value <- avgHR()
  valueBox(value = value$string, icon = "fa-heartbeat", color = 'danger')
})
```


Row
---

### Map {data-width=50%}

```{r}

output$map <- renderLeaflet({
  leaflet() %>%
    setView(lat=0, lng=0, zoom=2) %>%
    addProviderTiles(providers$CartoDB.Positron)
})
leafletOutput('map')

# clear, when we load new data
observe({
  req(input$fitFile)
  leafletProxy('map') %>%
    clearMarkers()
})

# set current marker when updated from charts or when we load new data
observe({
  current <- fitdata() %>% slice(input$currentLocation)
  leafletProxy('map') %>%
    clearGroup('current') %>%
    addMarkers(lng=current$long, current$lat, group='current')
})

# draw current range
observe({
  data <- mapdata() %>% select(c('lat', 'long', 'hrzone')) %>% drop_na()

  hrL = hrLabels()
  dz1 <- data %>% filter(hrzone==hrL[1]) %>% select('lat', 'long')
  dz2 <- data %>% filter(hrzone==hrL[2]) %>% select('lat', 'long')
  dz3 <- data %>% filter(hrzone==hrL[3]) %>% select('lat', 'long')
  dz4 <- data %>% filter(hrzone==hrL[4]) %>% select('lat', 'long')
  dz5 <- data %>% filter(hrzone==hrL[5]) %>% select('lat', 'long')

  leafletProxy('map') %>%
    clearMarkers() %>%
    fitBounds(min(data$long), min(data$lat), max(data$long), max(data$lat)) %>%
    addCircleMarkers(lng=dz1$long, lat=dz1$lat, fillColor=hrColors[1],
                     stroke=FALSE, radius=4, fillOpacity=1) %>%
    addCircleMarkers(lng=dz2$long, lat=dz2$lat, fillColor=hrColors[2],
                     stroke=FALSE, radius=4, fillOpacity=1) %>%
    addCircleMarkers(lng=dz3$long, lat=dz3$lat, fillColor=hrColors[3],
                     stroke=FALSE, radius=4, fillOpacity=1) %>%
    addCircleMarkers(lng=dz4$long, lat=dz4$lat, fillColor=hrColors[4],
                     stroke=FALSE, radius=4, fillOpacity=1) %>%
    addCircleMarkers(lng=dz5$long, lat=dz5$lat, fillColor=hrColors[5],
                     stroke=FALSE, radius=4, fillOpacity=1)
})
```

### Charts {data-width=50%}

```{r}
fillCol(
  flex = c(5,7),
 
  renderDygraph({
    data <- fitdata()

    hrB <- hrBreaks()
    tickerJs <- 'function(min, max, pixels, opts, dygraph, vals){return([])}'

    dygraph(xts(data[c('hr')], order.by=data$timestamp),
            group='global') %>%
      dyOptions(colors=c('black'), fillAlpha=0.1, fillGraph=TRUE) %>%
      dyCallbacks(highlightCallback=hlCallbackJs) %>%
      dyAxis("x", drawGrid=FALSE) %>%
      dyAxis('y', valueRange=c(hrB[1], hrB[6] + 1), ticker=tickerJs) %>%
      dyLimit(hrB[1], hrB[1], labelLoc="left", color="black") %>%
      dyLimit(hrB[2], hrB[2], labelLoc="left", color="black") %>%
      dyLimit(hrB[3], hrB[3], labelLoc="left", color="black") %>%
      dyLimit(hrB[4], hrB[4], labelLoc="left", color="black") %>%
      dyLimit(hrB[5], hrB[5], labelLoc="left", color="black") %>%
      dyShading(hrB[1], hrB[2], color=hrColors[1], axis="y") %>%
      dyShading(hrB[2], hrB[3], color=hrColors[2], axis="y") %>%
      dyShading(hrB[3], hrB[4], color=hrColors[3], axis="y") %>%
      dyShading(hrB[4], hrB[5], color=hrColors[4], axis="y") %>%
      dyShading(hrB[5], hrB[6], color=hrColors[5], axis="y")
  }),
  
  renderDygraph({
    data <- fitdata()

    drawCallbackJs<- 'function(g, i){
      Shiny.setInputValue("rangeStart", Dygraph.dateString_(g.xAxisRange()[0], "UTC"))
      Shiny.setInputValue("rangeStop", Dygraph.dateString_(g.xAxisRange()[1], "UTC"))
    }'
    
    dygraph(xts(data[c('pace', 'altitude')],
                order.by=data$timestamp), group='global') %>%
      dyCallbacks(highlightCallback=hlCallbackJs,
                  drawCallback=drawCallbackJs) %>%
      dySeries("altitude", axis = 'y2') %>%
      dyRangeSelector() %>%
      dyAxis("y", valueRange=c(0, max(data$pace))) %>%
      dyAxis("y2", valueRange=c(min(data$altitude),
                                min(data$altitude) +
                        (max(data$altitude) - min(data$altitude)) *2)) %>%
      dyAxis("x", drawGrid = FALSE)
  }) 
) 
```

Analysis
========

Row {data-height=80}
--------------------

### HR range
```{r}
renderUI({
  sliderInput('HRrange', value=c(hrBreaks()[2],hrBreaks()[6]), min=110, max=220,
              'Limit analysis to this heart rate range.')
})
```

### slope window
```{r}
sliderInput('slopeWindow', value=3, min=1, max=20, step=1,
            'Average slope window.')
```

### HR window
```{r}
sliderInput('hrWindow', value=4, min=1, max=20, step=1,
            'Average hr window.')
```

### speed window
```{r}
sliderInput('speedWindow', value=5, min=1, max=10, step=1,
            'Average speed window.')
```

Row {data-height=80}
--------------------

### min group size
```{r}
sliderInput('minGroup', value=10, min=1, max=100, '')
```

### slope Limit
```{r}
sliderInput('slopeLimit', value=0.1, min=0, max=10, step=0.1,
            'Slope limit')
```

### HR Limit
```{r}
sliderInput('hrLimit', value=1, min=0, max=3, step=0.25,
            'HR limit')
```

### speed Limit
```{r}
sliderInput('speedLimit', value=0.05, min=0, max=0.5, step=0.01,
            'Speed limit')
```

Row {.tabset}
---


### HR-Pace Index

```{r}
renderPlot({
  data <- analysisdata()

  baseplot <- ggplot(data) +
    geom_rect(mapping=aes(ymin=-Inf, ymax=Inf), fill=hrColors[5],
              xmin=-Inf, xmax=Inf, alpha=1) +
    geom_rect(mapping=aes(ymin=-Inf, ymax=hrBreaks()[5]), fill=hrColors[4],
              xmin=-Inf, xmax=Inf, alpha=1) +
    geom_rect(mapping=aes(ymin=-Inf, ymax=hrBreaks()[4]), fill=hrColors[3],
              xmin=-Inf, xmax=Inf, alpha=1) +
    geom_rect(mapping=aes(ymin=-Inf, ymax=hrBreaks()[3]), fill=hrColors[2],
              xmin=-Inf, xmax=Inf, alpha=1) +
    geom_rect(mapping=aes(ymin=-Inf, ymax=hrBreaks()[2]), fill=hrColors[1],
              xmin=-Inf, xmax=Inf, alpha=1) +
    scale_y_continuous(name='Heart Rate', breaks=unique(data$hr),
                       limits=c(input$HRrange[1], input$HRrange[2]),
                       sec.axis = dup_axis(breaks=(hrBreaks()[1:5] + hrBreaks()[2:6])/2,
                                           labels=hrLabels())) +
    geom_hline(yintercept = hrBreaks()[2:5]) +
    scale_x_continuous(trans = "identity") + # reverse
    geom_point(aes(speed, hr))

  if(nrow(data) >= 10){
    m <- loess(hr ~ speed, data = data, span=0.75)
    md <- data.frame(speed=data$speed, hr=m$fitted)
    baseplot +
      geom_smooth(aes(speed, hr), formula=y~x, method='loess', span=0.75) +
      geom_smooth(aes(speed, hr), formula=y~x, method='lm', se=FALSE, color='red', linetype='dashed')
  } else {
    baseplot +
      ggtitle('Not enough data')
  }

})
```


### Gradient Histogram

```{r}
renderPlot({
  data <- analysisdata()

  ggplot(data, aes(abs(slope))) +
    geom_histogram()
})
```

Row {data-height=80}
--------------------

### Lactate Threshold (modified D-Max) {.value-box}

```{r}
hrdp <- reactive({
  data <- analysisdata()
  tryCatch(
    {
    hrdp <- calc_hrdp(data)
    list(string=sprintf('%s min/km | %.0f bpm', format_pace(hrdp$pace), round(hrdp$hr)),
         numeric=hrdp$speed)
    }, error = function(cond) {
      message('Could not calculate hrdp')
      list(string=cond$message)
    })
})

renderValueBox({
  value <- hrdp()
  valueBox(value = value$string, icon = "fa-tachometer-alt", color = 'primary')
})
```