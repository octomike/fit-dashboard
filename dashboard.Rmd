---
title: "Runboard"
output: 
  flexdashboard::flex_dashboard:
    css: styles.css
    theme: united
    orientation: rows
    social: menu
runtime: shiny
---

```{r setup, include=FALSE}
library(flexdashboard)
library(dplyr)
library(leaflet)
library(tidyr)
library(dygraphs)
library(xts)
library(stringr)
library(elevatr)
library(rgdal)
library(ggplot2)
library(devtools)
library(lubridate)
library(fit) # install_github('octomike/fit')


# helpers
source("helpers/data.R")
```


Sidebar {.sidebar}
==================

### Open activity:

```{r}
fileInput('fitFile', label='Only .fit files are supported')
```


### Heart Rate Zones

```{r}
selectInput('hrmethod', 'HR based on', c('Lactate Threshold', 'Maximum HR'))
sliderInput('hrthresh', 'HR in bpm', 180, min=150, max=220)
```

### Elevation Correction

If your device does not have a barometric sensor, try to correct GPS data with a [external radar data](https://cran.r-project.org/web/packages/elevatr/vignettes/introduction_to_elevatr.html).

```{r}
checkboxInput('fixElevation', label='Fix Elevation', value=FALSE)
```


```{r}
# hide inputs with css and use from dygraph JS callbacks
numericInput('currentLocation', '', value=1)
dateInput('rangeStart', '', NULL)
dateInput('rangeStop', '', NULL)
```

```{r}

# rawdata contains $records timeseries and some metadata
rawdata <- reactive({
  req(input$fitFile)
  elevationCache(NULL) # drop the cache
  read.fit(input$fitFile$datapath)
})

# data cleaning and fixing
fitdata <- reactive({
    raw <- rawdata()
    if (str_detect(input$hrmethod, 'Lactate')) {
      if ('threshold_heart_rate' %in% names(raw$zones_target)) {
        value <- raw$zones_target$threshold_heart_rate
        updateSliderInput(session, 'hrthresh', label='HR in bpm (from fit file)', min=150, max=220, value=value)
      }
    } else {
      if ('max_heart_rate' %in% names(raw$zones_target)) {
        value <- raw$zones_target$max_heart_rate
        updateSliderInput(session, 'hrthresh', label='HR in bpm (from fit file)', min=150, max=220, value=value)
      }
    }
    df <- raw$record %>%
      tbl_df %>%
      run_rename_select %>%
      run_fix_units %>%
      run_fix_elevation(skip=!input$fixElevation, cache=elevationCache()) %>%
      run_add_gain %>%
      run_add_pace
    if (input$fixElevation && is.null(elevationCache())) {
      elevationCache(df$altitude)
    }
    df
})

# limit data to range from dygraph
rangedata <- reactive({
  fitdata() %>%
    run_filter_fitrange(start=input$rangeStart, stop=input$rangeStop) %>%
    run_add_hrzone(breaks=hrBreaks(), labels=hrLabels())
})

mapdata <- reactive({
  rd <- rangedata()
  tres <- rd %>%
            mutate(td=as.numeric(timestamp - lag(timestamp))) %>%
            select('td') %>%
            drop_na() %>% 
            summarise(mean(td)) %>%
            pull()

  if (tres <= 2){
    rd %>%
      filter(!(row_number() %% max(floor(tres), 4))) # TODO consider making this an input
  } else {
    rd
  }
})

# depends on maximum hr in range
# used to restrict the extent of HR-Zone-plot
hrBreaks <- reactive({
  thresh <- input$hrthresh
  # https://www.researchgate.net/figure/The-5-Zone-Intensity-Scale-Used-by-the-Norwegian-Olympic-Federation-and-the-3-Zone-and_tbl1_259652575
  breaks <- thresh * c(0.72, 0.82, 0.87, 0.92, 1)
  if (str_detect(input$hrmethod, 'Lactate')) {
    breaks <- breaks / 0.92
  }
  breaks <- round(breaks)
  c(min(breaks[1]-1, min(fitdata()$hr)), breaks)
})

elevationCache <- reactiveVal(NULL)

# statics
hrLabels <- reactiveVal(c('Z1', 'Z2', 'Z3', 'Z4', 'Z5'))
hrColors <- c('#c4ced4', '#b0dcf7', '#b9dfa0', '#fbd89e', '#faa8b1')
hlCallbackJs <- 'function(event, x, points, row, seriesName){
  Shiny.setInputValue("currentLocation", row);
  for (div of document.getElementsByClassName("dygraphs")) {
    var obj = window.HTMLWidgets.getInstance(div);
    obj.dygraph.setSelection(row);
  }
}'
```

Summary
=======

Row
---

### Pace {.value-box}

```{r}
avgPace <- reactive({
  data <- rangedata()
  d <- ( tail(data$distance, n=1) - head(data$distance, n=1) ) / 1000
  t <- as.numeric(
    difftime(tail(data$timestamp, n=1), data$timestamp[1], unit='mins')
  )
  pace <- t/d
  pre <- floor(pace)
  list(string=sprintf('%d:%02d min/km', pre, floor(60 * (pace - pre))),
       numeric=pace)
})

renderValueBox({
  value <- avgPace()
  valueBox(value = value$string, icon = "fa-tachometer-alt", color = 'success')
})
```

### Time {.value-box}

```{r}
runTime <- reactive({
  data <- rangedata() %>% slice(1, n()) %>%  select('timestamp') %>% pull
  diff <- as.numeric(data[2] - data[1], units='secs')
  list(string=tolower(seconds_to_period(diff)), numeric=diff)
})

renderValueBox({
  value <- runTime()
  valueBox(value = value$string, icon = "fa-stopwatch", color = 'success')
})
```

### Distance {.value-box}

```{r}
distance <- reactive({
  data <- rangedata()
  d <- ( tail(data$distance, n=1) - head(data$distance, n=1) ) / 1000
  list(string=sprintf('%0.2f km', d), numeric=d)
})

renderValueBox({
  value = distance()
  valueBox(value = value$string, icon = "fa-road", color = 'success' )
})
```


### Elevation Gain (imprecise) {.value-box}

```{r}
elGain <- reactive({
  gains <- rangedata()$gain
  gain <- floor(sum( gains[gains>0] ))
  list(string=sprintf('%d m', gain), numeric=gain)
})

renderValueBox({
  value <- elGain()
  valueBox(value = value$string, icon = "fa-signal", color = 'success')
})
```

### Average HR {.value-box}

```{r}
avgHR <- reactive({
  avghr <- round(mean(rangedata()$hr))
  list(string=sprintf('%d bpm', avghr), numeric=avghr)
})

renderValueBox({
  value <- avgHR()
  valueBox(value = value$string, icon = "fa-heartbeat", color = 'danger')
})
```


Row
---

### Map {data-width=50%}

```{r}

output$map <- renderLeaflet({
  leaflet() %>%
    setView(lat=0, lng=0, zoom=2) %>%
    addProviderTiles(providers$CartoDB.Positron)
})
leafletOutput('map')

# clear, when we load new data
observe({
  req(input$fitFile)
  leafletProxy('map') %>%
    clearMarkers()
})

# set current marker when updated from charts or when we load new data
observe({
  current <- fitdata() %>% slice(input$currentLocation)
  leafletProxy('map') %>%
    clearGroup('current') %>%
    addMarkers(lng=current$long, current$lat, group='current')
})

# draw current range
observe({
  data <- mapdata() %>% select(c('lat', 'long', 'hrzone')) %>% drop_na()

  hrL = hrLabels()
  dz1 <- data %>% filter(hrzone==hrL[1]) %>% select('lat', 'long')
  dz2 <- data %>% filter(hrzone==hrL[2]) %>% select('lat', 'long')
  dz3 <- data %>% filter(hrzone==hrL[3]) %>% select('lat', 'long')
  dz4 <- data %>% filter(hrzone==hrL[4]) %>% select('lat', 'long')
  dz5 <- data %>% filter(hrzone==hrL[5]) %>% select('lat', 'long')

  leafletProxy('map') %>%
    clearMarkers() %>%
    fitBounds(min(data$long), min(data$lat), max(data$long), max(data$lat)) %>%
    addCircleMarkers(lng=dz1$long, lat=dz1$lat, fillColor=hrColors[1],
                     stroke=FALSE, radius=4, fillOpacity=1) %>%
    addCircleMarkers(lng=dz2$long, lat=dz2$lat, fillColor=hrColors[2],
                     stroke=FALSE, radius=4, fillOpacity=1) %>%
    addCircleMarkers(lng=dz3$long, lat=dz3$lat, fillColor=hrColors[3],
                     stroke=FALSE, radius=4, fillOpacity=1) %>%
    addCircleMarkers(lng=dz4$long, lat=dz4$lat, fillColor=hrColors[4],
                     stroke=FALSE, radius=4, fillOpacity=1) %>%
    addCircleMarkers(lng=dz5$long, lat=dz5$lat, fillColor=hrColors[5],
                     stroke=FALSE, radius=4, fillOpacity=1)
})
```

### Charts {data-width=50%}

```{r}
fillCol(
  flex = c(5,7),
 
  renderDygraph({
    data <- fitdata()

    hrB <- hrBreaks()
    tickerJs <- 'function(min, max, pixels, opts, dygraph, vals){return([])}'

    dygraph(xts(data[c('hr')], order.by=data$timestamp),
            group='global') %>%
      dyOptions(colors=c('black'), fillAlpha=0.1, fillGraph=TRUE) %>%
      dyCallbacks(highlightCallback=hlCallbackJs) %>%
      dyAxis("x", drawGrid=FALSE) %>%
      dyAxis('y', valueRange=c(hrB[1], hrB[6] + 1), ticker=tickerJs) %>%
      dyLimit(hrB[1], hrB[1], labelLoc="left", color="black") %>%
      dyLimit(hrB[2], hrB[2], labelLoc="left", color="black") %>%
      dyLimit(hrB[3], hrB[3], labelLoc="left", color="black") %>%
      dyLimit(hrB[4], hrB[4], labelLoc="left", color="black") %>%
      dyLimit(hrB[5], hrB[5], labelLoc="left", color="black") %>%
      dyShading(hrB[1], hrB[2], color=hrColors[1], axis="y") %>%
      dyShading(hrB[2], hrB[3], color=hrColors[2], axis="y") %>%
      dyShading(hrB[3], hrB[4], color=hrColors[3], axis="y") %>%
      dyShading(hrB[4], hrB[5], color=hrColors[4], axis="y") %>%
      dyShading(hrB[5], hrB[6], color=hrColors[5], axis="y")
  }),
  
  renderDygraph({
    data <- fitdata()

    drawCallbackJs<- 'function(g, i){
      Shiny.setInputValue("rangeStart", Dygraph.dateString_(g.xAxisRange()[0], "UTC"))
      Shiny.setInputValue("rangeStop", Dygraph.dateString_(g.xAxisRange()[1], "UTC"))
    }'
    
    dygraph(xts(data[c('pace', 'altitude')],
                order.by=data$timestamp), group='global') %>%
      dyCallbacks(highlightCallback=hlCallbackJs,
                  drawCallback=drawCallbackJs) %>%
      dySeries("altitude", axis = 'y2') %>%
      dyRangeSelector() %>%
      dyAxis("y", valueRange=c(0, max(data$pace))) %>%
      dyAxis("y2", valueRange=c(min(data$altitude),
                                min(data$altitude) +
                        (max(data$altitude) - min(data$altitude)) *2)) %>%
      dyAxis("x", drawGrid = FALSE)
  }) 
) 
```

Analysis
========

Row {data-height=80}
--------------------

### HR range
```{r}
renderUI({
  sliderInput('HRrange', value=c(hrBreaks()[2],hrBreaks()[6]), min=110, max=220,
              'Limit analysis to this heart rate range.')
})
```

### HR group size
```{r}
sliderInput('hrGroupSize', value=1, min=1, max=5, step=1,
            'Try to smooth the index by grouping neighbouring heart rate values.')
```

### max gradient
```{r}
renderUI({
  sliderInput('maxGain', value=round(quantile(abs(rangedata()$gain), probs=c(0.5)), 1),
              min=0, max=ceiling(max(abs(rangedata()$gain))), step=0.005,
              'Remove all data pairs where the absolute estimated altitude
               gradient is smaller than this value (prefer flat segments).')
})
```

### min group size
```{r}
sliderInput('minGroup', value=15, min=1, max=100,
            'Ignore data pairs wich occured fewer than this value')
```


Row {.tabset}
---

```{r}
analysisdata <- reactive({
  rangedata() %>%
    select(c('gain', 'pace', 'hr')) %>%
    filter(hr >= input$HRrange[1]) %>%
    filter(hr <= input$HRrange[2]) %>%
    filter(abs(gain) <= input$maxGain) %>%
    mutate(hrg=floor(hr/input$hrGroupSize)*input$hrGroupSize) %>%
    group_by(hrg) %>%
    filter(n()>input$minGroup) %>%
    mutate(med=median(pace), avg=mean(pace),
           lwr=median(pace)-sd(pace), upr=median(pace)+sd(pace)) %>%
    filter((abs(pace- median(pace)) <= 2 * sd(pace)))
})
```

### HR-Pace Index

```{r}

renderPlot({
  data <- analysisdata()

  ggplot(data, aes(hrg, pace)) +
    scale_x_continuous(name='Heart Rate', breaks=unique(data$hrg),
                       limits=c(input$HRrange[1], input$HRrange[2])) +
    scale_y_continuous(trans = "reverse") +
    geom_point() +
    geom_smooth(method='loess', n=20)

})
```

### Gradient Histogram

```{r}
renderPlot({
  data <- analysisdata()

  ggplot(data, aes(abs(gain))) +
    geom_histogram()
})
```
